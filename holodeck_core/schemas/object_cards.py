"""Object card schemas for Scene Analysis module.

Based on HOLODECK 2.0 Supplementary Material 6.2.
"""

from typing import List, Optional, Literal
from datetime import datetime, timezone
from pydantic import BaseModel, Field, field_validator, ConfigDict


class ObjectCard(BaseModel):
    """Individual object card generated for Scene Analysis.

    Represents the frontal PNG image generated for each scene object.
    """
    object_id: str = Field(..., description="Unique object identifier")
    object_name: str = Field(..., description="Object name as used in the prompt")
    card_image_path: str = Field(..., description="Path to generated PNG image")
    prompt_used: str = Field(..., description="Exact prompt used for generation")
    generation_time: float = Field(..., ge=0.0, description="Generation time in seconds")
    qc_status: Literal["pending", "approved", "rejected"] = Field("pending", description="Quality control status")
    rejection_reason: Optional[str] = Field(None, description="Reason for rejection if applicable")

    model_config = ConfigDict(
        str_strip_whitespace=True,
        validate_assignment=True,
        json_schema_extra={
            "reference": "HOLODECK 2.0 Supp 6.2 - Generate Individual Images",
            "examples": [
                {
                    "object_id": "bed1",
                    "object_name": "King Bed",
                    "card_image_path": "workspace/sessions/2026-01-12T12-30-05Z_abc123/object_cards/bed1.png",
                    "prompt_used": "Please generate ONE PNG image of an isolated front-view King Bed with a transparent background, in realistic style, with shapes and style similar to the reference scene.",
                    "generation_time": 2.3,
                    "qc_status": "approved"
                }
            ]
        }
    )


class SceneRefImage(BaseModel):
    """Scene reference image generated by GPT-Image-1.

    First step in Scene Analysis - generates a reference image based on text description.
    """
    image_path: str = Field(..., description="Path to generated reference image")
    prompt_used: str = Field(..., description="Exact prompt used for generation")
    style: str = Field(..., description="Artistic style specified in prompt")
    generation_time: float = Field(..., ge=0.0, description="Generation time in seconds")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), description="Creation timestamp")

    model_config = ConfigDict(
        validate_assignment=True,
        json_schema_extra={
            "reference": "HOLODECK 2.0 Supp 6.2.1 - Generate Reference Image",
            "examples": [
                {
                    "image_path": "workspace/sessions/2026-01-12T12-30-05Z_abc123/scene_ref.png",
                    "prompt_used": "A cozy bedroom with a modern minimalist style. Render in realistic style. 3-D view: x->right, y->backward, z->up. Well-lit, no extra objects.",
                    "style": "realistic",
                    "generation_time": 3.7
                }
            ]
        }
    )


class BackgroundImage(BaseModel):
    """Background/ground texture image extracted from reference image.

    Used for seamless tiling in the final scene rendering.
    """
    image_path: str = Field(..., description="Path to generated background image")
    source_reference: str = Field(..., description="Path to reference image used for extraction")
    tileable: bool = Field(True, description="Whether the image is tileable/seamless")
    surface_type: Literal["floor", "ground", "wall", "other"] = Field(..., description="Type of surface")
    material_description: Optional[str] = Field(None, description="Description of the material pattern")
    generation_time: float = Field(..., ge=0.0, description="Generation time in seconds")

    model_config = ConfigDict(
        validate_assignment=True,
        json_schema_extra={
            "reference": "HOLODECK 2.0 Supp 6.2.6 - Generate Background Image",
            "examples": [
                {
                    "image_path": "workspace/sessions/2026-01-12T12-30-05Z_abc123/background.png",
                    "source_reference": "workspace/sessions/2026-01-12T12-30-05Z_abc123/scene_ref.png",
                    "tileable": True,
                    "surface_type": "floor",
                    "material_description": "Light wood plank with subtle grain",
                    "generation_time": 2.1
                }
            ]
        }
    )


class ObjectCardBatch(BaseModel):
    """Batch of object cards generated for a scene."""
    batch_id: str = Field(..., description="Unique batch identifier")
    scene_session_id: str = Field(..., description="Associated scene session ID")
    total_objects: int = Field(..., description="Total number of objects processed")
    successful_cards: List[ObjectCard] = Field(..., description="Successfully generated cards")
    failed_objects: List[str] = Field(default_factory=list, description="Object IDs that failed generation")

    # Generation metadata
    parallel_workers: int = Field(1, description="Number of parallel workers used")
    total_time: float = Field(..., ge=0.0, description="Total batch generation time")

    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), description="Creation timestamp")

    model_config = ConfigDict(
        validate_assignment=True,
        json_schema_extra={
            "examples": [
                {
                    "batch_id": "batch_20260112_123005",
                    "scene_session_id": "2026-01-12T12-30-05Z_abc123",
                    "total_objects": 5,
                    "successful_cards": [
                        {
                            "object_id": "bed1",
                            "object_name": "King Bed",
                            "card_image_path": "object_cards/bed1.png",
                            "qc_status": "approved"
                        }
                    ],
                    "parallel_workers": 3,
                    "total_time": 8.4
                }
            ]
        }
    )

    @field_validator('successful_cards')
    @classmethod
    def validate_batch_completeness(cls, v, info):
        """Ensure batch integrity."""
        total = info.data.get('total_objects', 0)
        failed = len(info.data.get('failed_objects', []))
        successful = len(v)

        if successful + failed != total:
            raise ValueError(
                f"Batch integrity check failed: {successful} successful + {failed} failed "
                f"!= {total} total objects"
            )
        return v