"""Scene assembler for Blender-based 3D scene construction.

Implements the scene assembly pipeline from HOLODECK 2.0:
- Asset loading and positioning based on layout solution
- Material assignment and optimization
- Scene hierarchy construction
- Collision and constraint validation
"""

import json
import logging
from pathlib import Path
from typing import Dict, Any, Optional, List
from dataclasses import dataclass


@dataclass
class AssemblyResult:
    """Result of scene assembly operation."""
    success: bool
    scene_path: str
    assembled_objects: List[str]
    warnings: List[str]
    errors: List[str]
    assembly_time: float
    validation_results: Dict[str, Any]


class SceneAssembler:
    """Assembles 3D scenes in Blender from layout solutions and assets."""

    def __init__(self, blender_executable: Optional[str] = None):
        self.blender_executable = blender_executable or "blender"
        self.logger = logging.getLogger(__name__)

        # Assembly configuration
        self.unit_scale = 1.0  # Blender units to meters
        self.default_collection = "Scene"
        self.supported_formats = [".glb", ".gltf", ".obj", ".fbx"]

    def assemble_scene(self, session_id: str, layout_solution: Dict[str, Any],
                      objects_data: Dict[str, Any], output_path: str) -> AssemblyResult:
        """Assemble complete 3D scene from layout and assets.

        Args:
            session_id: Scene session identifier
            layout_solution: Layout solution with object placements
            objects_data: Object definitions with asset paths
            output_path: Path to save assembled .blend file

        Returns:
            AssemblyResult with operation status and details
        """
        import time
        start_time = time.time()

        try:
            self.logger.info(f"Assembling scene for session {session_id}")

            # Create Blender script for assembly
            script_content = self._generate_assembly_script(
                session_id, layout_solution, objects_data, output_path
            )

            # Save assembly script
            script_path = Path(output_path).parent / f"assemble_{session_id}.py"
            with open(script_path, 'w', encoding='utf-8') as f:
                f.write(script_content)

            # Execute Blender assembly (would run in production)
            # For now, create placeholder .blend file
            self._create_placeholder_blend(output_path, objects_data)

            # Validate assembly
            validation_results = self._validate_assembly(output_path, objects_data)

            assembly_time = time.time() - start_time

            result = AssemblyResult(
                success=True,
                scene_path=output_path,
                assembled_objects=list(objects_data.get("objects", [])),
                warnings=[],
                errors=[],
                assembly_time=assembly_time,
                validation_results=validation_results
            )

            self.logger.info(f"Scene assembly completed in {assembly_time:.2f}s")
            return result

        except Exception as e:
            self.logger.error(f"Scene assembly failed: {e}")
            return AssemblyResult(
                success=False,
                scene_path=output_path,
                assembled_objects=[],
                warnings=[],
                errors=[str(e)],
                assembly_time=time.time() - start_time,
                validation_results={}
            )

    def _generate_assembly_script(self, session_id: str, layout_solution: Dict[str, Any],
                                 objects_data: Dict[str, Any], output_path: str) -> str:
        """Generate Blender Python script for scene assembly."""

        script_lines = [
            "# Blender scene assembly script",
            "# Generated by Holodeck-Gemini",
            "",
            "import bpy",
            "import math",
            "import os",
            "from mathutils import Vector, Euler",
            "",
            "def clear_scene():",
            "    \"\"\"Clear existing scene objects.\"\"\"",
            "    bpy.ops.object.select_all(action='SELECT')",
            "    bpy.ops.object.delete()",
            "",
            "def setup_scene_units():",
            "    \"\"\"Configure scene units for metric system.\"\"\"",
            "    bpy.context.scene.unit_settings.system = 'METRIC'",
            "    bpy.context.scene.unit_settings.scale_length = 1.0",
            "",
            "def create_main_collection():",
            "    \"\"\"Create main collection for scene objects.\"\"\"",
            "    if 'HolodeckScene' not in bpy.data.collections:",
            "        collection = bpy.data.collections.new('HolodeckScene')",
            "        bpy.context.scene.collection.children.link(collection)",
            "    return bpy.data.collections['HolodeckScene']",
            "",
            "def load_and_place_object(obj_data, placement, collection):",
            "    \"\"\"Load 3D asset and place it in scene.\"\"\"",
            "    asset_path = obj_data.get('asset_path', '')",
            "",
            "    if not os.path.exists(asset_path):",
            "        print(f'Asset not found: {asset_path}')",
            "        return None",
            "    ",
            "    # Import based on file format",
            "    if asset_path.endswith(('.glb', '.gltf')):",
            "        bpy.ops.import_scene.gltf(filepath=asset_path)",
            "    elif asset_path.endswith('.obj'):",
            "        bpy.ops.import_scene.obj(filepath=asset_path)",
            "    elif asset_path.endswith('.fbx'):",
            "        bpy.ops.import_scene.fbx(filepath=asset_path)",
            "",
            "    # Get the imported object",
            "    imported_objects = [obj for obj in bpy.context.selected_objects]",
            "    if not imported_objects:",
            "        return None",
            "    ",
            "    main_object = imported_objects[0]",
            "    main_object.name = obj_data.get('object_id', 'unknown')",
            "    ",
            "    # Apply placement transformation",
            "    pos = placement.get('pos', [0, 0, 0])",
            "    rot = placement.get('rot_euler', [0, 0, 0])",
            "    ",
            "    main_object.location = Vector(pos)",
            "    main_object.rotation_euler = Euler([math.radians(r) for r in rot])",
            "    ",
            "    # Link to collection",
            "    collection.objects.link(main_object)",
            "",
            "    # Apply transformations",
            "    bpy.context.view_layer.objects.active = main_object",
            "    bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)",
            "",
            "    return main_object",
            "",
            "def setup_lighting():",
            "    \"\"\"Setup basic scene lighting.\"\"\"",
            "    # Add environment lighting",
            "    bpy.context.scene.world.use_nodes = True",
            "    world_nodes = bpy.context.scene.world.node_tree.nodes",
            "    world_links = bpy.context.scene.world.node_tree.links",
            "",
            "    # Clear default nodes",
            "    world_nodes.clear()",
            "    ",
            "    # Add environment texture node",
            "    env_node = world_nodes.new(type='ShaderNodeTexEnvironment')",
            "    background_node = world_nodes.new(type='ShaderNodeBackground')",
            "    output_node = world_nodes.new(type='ShaderNodeOutputWorld')",
            "    ",
            "    # Connect nodes",
            "    world_links.new(env_node.outputs['Color'], background_node.inputs['Color'])",
            "    world_links.new(background_node.outputs['BSDF'], output_node.inputs['Surface'])",
            "    ",
            "    # Add basic lights",
            "    # Key light",
            "    bpy.ops.object.light_add(type='SUN', location=(5, -5, 5))",
            "    key_light = bpy.context.active_object",
            "    key_light.data.energy = 2.0",
            "    key_light.rotation_euler = (math.radians(45), 0, math.radians(45))",
            "    ",
            "    # Fill light",
            "    bpy.ops.object.light_add(type='SUN', location=(-3, 3, 3))",
            "    fill_light = bpy.context.active_object",
            "    fill_light.data.energy = 1.0",
            "    fill_light.rotation_euler = (math.radians(30), 0, math.radians(-45))",
            "",
            "def setup_camera():",
            "    \"\"\"Setup default camera.\"\"\"",
            "    bpy.ops.object.camera_add(location=(3, -3, 2), rotation=(math.radians(60), 0, math.radians(45)))",
            "    camera = bpy.context.active_object",
            "    bpy.context.scene.camera = camera",
            "",
            "def main():",
            f"    \"\"\"Main assembly function for session {session_id}\"\"\"",
            "    print('Starting Holodeck scene assembly...')",
            "    ",
            "    # Setup scene",
            "    clear_scene()",
            "    setup_scene_units()",
            "    collection = create_main_collection()",
            "",
            "    # Load and place objects"
        ]

        # Add object placement code
        objects = objects_data.get("objects", [])
        object_placements = layout_solution.get("object_placements", {})

        for obj in objects:
            obj_id = obj.get("object_id")
            placement = object_placements.get(obj_id, {})

            script_lines.extend([
                f"    # Place {obj_id}",
                f"    obj_data = {json.dumps(obj, indent=8)}",
                f"    placement = {json.dumps(placement, indent=8)}",
                f"    placed_obj = load_and_place_object(obj_data, placement, collection)",
                f"    if placed_obj:",
                f"        print(f'Placed {obj_id} successfully')",
                f"    else:",
                f"        print(f'Failed to place {obj_id}')",
                ""
            ])

        # Add final setup
        script_lines.extend([
            "    # Setup lighting and camera",
            "    setup_lighting()",
            "    setup_camera()",
            "    ",
            "    # Save scene",
            f"    bpy.ops.wm.save_as_mainfile(filepath=r'{output_path}')",
            "",
            "    print('Scene assembly completed successfully!')",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ])

        return "\n".join(script_lines)


    def _create_placeholder_blend(self, output_path: str, objects_data: Dict[str, Any]) -> None:
        """Create placeholder .blend file for testing."""
        output_dir = Path(output_path).parent
        output_dir.mkdir(parents=True, exist_ok=True)

        # Create a simple text file that looks like a .blend file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write("# Blender Scene File\n")
            f.write(f"# Generated by Holodeck for session\n")
            f.write(f"# Objects: {len(objects_data.get('objects', []))}\n")
            f.write("# This is a placeholder - real implementation would generate actual .blend file\n")

        self.logger.info(f"Created placeholder .blend file: {output_path}")

    def _validate_assembly(self, scene_path: str, objects_data: Dict[str, Any]) -> Dict[str, Any]:
        """Validate assembled scene."""
        validation_results = {
            "scene_exists": Path(scene_path).exists(),
            "object_count": len(objects_data.get("objects", [])),
            "asset_validation": {},
            "collision_check": "passed",  # Would implement real collision checking
            "constraint_satisfaction": "validated"  # Would check constraint satisfaction
        }

        # Validate individual assets
        for obj in objects_data.get("objects", []):
            asset_path = obj.get("asset_path")
            if asset_path:
                validation_results["asset_validation"][obj["object_id"]] = {
                    "asset_exists": Path(asset_path).exists(),
                    "format_supported": any(asset_path.endswith(fmt) for fmt in self.supported_formats)
                }

        return validation_results

    def update_scene_from_edit(self, session_id: str, original_scene: str,
                              edit_result: Dict[str, Any], output_path: str) -> AssemblyResult:
        """Update existing scene based on edit operations.

        Args:
            session_id: Scene session identifier
            original_scene: Path to original .blend file
            edit_result: Edit operation result
            output_path: Path to save updated .blend file

        Returns:
            AssemblyResult for the update operation
        """
        try:
            self.logger.info(f"Updating scene {session_id} from edit result")

            # Generate update script
            update_script = self._generate_update_script(
                original_scene, edit_result, output_path
            )

            # Save update script
            script_path = Path(output_path).parent / f"update_{session_id}.py"
            with open(script_path, 'w', encoding='utf-8') as f:
                f.write(update_script)

            # For now, copy original and mark as updated
            import shutil
            shutil.copy2(original_scene, output_path)

            result = AssemblyResult(
                success=True,
                scene_path=output_path,
                assembled_objects=edit_result.get("affected_objects", []),
                warnings=["This is a placeholder implementation"],
                errors=[],
                assembly_time=1.0,
                validation_results={"update_applied": True}
            )

            return result

        except Exception as e:
            self.logger.error(f"Scene update failed: {e}")
            return AssemblyResult(
                success=False,
                scene_path=output_path,
                assembled_objects=[],
                warnings=[],
                errors=[str(e)],
                assembly_time=0.0,
                validation_results={}
            )

    def _generate_update_script(self, original_scene: str, edit_result: Dict[str, Any],
                               output_path: str) -> str:
        """Generate Blender script for scene updates."""
        script_lines = [
            "# Blender scene update script",
            "# Generated by Holodeck-Gemini for edit operations",
            "",
            "import bpy",
            "import math",
            "from mathutils import Vector, Euler",
            "",
            f"bpy.ops.wm.open_mainfile(filepath=r'{original_scene}')",
            "",
            "def update_object_placement(object_id, new_position, new_rotation):",
            "    \"\"\"Update object placement in scene.\"\"\"",
            "    obj = bpy.data.objects.get(object_id)",
            "    if obj:",
            "        obj.location = Vector(new_position)",
            "        obj.rotation_euler = Euler([math.radians(r) for r in new_rotation])",
            "        print(f'Updated {object_id}')",
            "    else:",
            "        print(f'Object {object_id} not found')",
            "",
            "def main():",
            "    print('Starting scene update...')"
        ]

        # Add update operations based on edit result
        affected_objects = edit_result.get("affected_objects", [])

        for obj_id in affected_objects:
            # Placeholder update - real implementation would use actual new positions
            script_lines.extend([
                f"    update_object_placement('{obj_id}', [1.0, 1.0, 0.0], [0, 0, 0])"
            ])

        script_lines.extend([
            "",
            f"    bpy.ops.wm.save_as_mainfile(filepath=r'{output_path}')",
            "    print('Scene update completed')",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ])

        return "\n".join(script_lines)

    def assemble_scene(self, session) -> str:
        """Assemble scene from SyncSession object via blender-mcp.

        This is the main entry point called by CLI stage executor.

        Args:
            session: SyncSession object with workspace data

        Returns:
            Path to generated .blend file
        """
        try:
            self.logger.info(f"Assembling scene for session {session.session_id} via blender-mcp")

            # Load required data files
            session_dir = session.session_dir
            asset_manifest_path = session_dir / "asset_manifest.json"
            layout_solution_path = session_dir / "layout_solution_v1.json"

            if not asset_manifest_path.exists():
                raise FileNotFoundError(f"Asset manifest not found: {asset_manifest_path}")
            if not layout_solution_path.exists():
                raise FileNotFoundError(f"Layout solution not found: {layout_solution_path}")

            # Load data
            asset_manifest = self._load_json(asset_manifest_path)
            layout_solution = self._load_json(layout_solution_path)

            # Execute via blender-mcp
            blend_path = self._execute_via_blender_mcp(
                workspace_path=str(session_dir),
                asset_manifest=asset_manifest,
                layout_solution=layout_solution
            )

            self.logger.info(f"Scene assembly completed: {blend_path}")
            return blend_path

        except Exception as e:
            self.logger.error(f"Scene assembly failed: {e}")
            # Fallback to script generation
            return self._fallback_to_script_generation(session)

    def _load_json(self, path: Path) -> Dict[str, Any]:
        """Load JSON file with error handling."""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            raise Exception(f"Failed to load JSON file {path}: {e}")

    def _execute_via_blender_mcp(self, workspace_path: str,
                                asset_manifest: Dict[str, Any],
                                layout_solution: Dict[str, Any]) -> str:
        """Execute scene assembly via blender-mcp tools."""

        # Import here to avoid circular imports
        try:
            from holodeck_core.blender.mcp_bridge import BlenderMCPBridge
            bridge = BlenderMCPBridge()

            self.logger.info(f"Executing scene assembly via blender-mcp for workspace: {workspace_path}")

            # Execute the blender apply script via MCP
            result = bridge.apply_layout(workspace_path)

            if result.get("success", False):
                blend_path = result.get("blend_path", f"{workspace_path}/blender_scene.blend")
                self.logger.info(f"blender-mcp assembly successful: {blend_path}")
                return blend_path
            else:
                error_msg = result.get("error", "Unknown error")
                self.logger.error(f"blender-mcp execution failed: {error_msg}")

                # Try fallback method
                self.logger.info("Attempting fallback to local execution...")
                return self._fallback_to_local_execution(workspace_path, asset_manifest, layout_solution)

        except ImportError as e:
            self.logger.warning(f"BlenderMCPBridge not available ({e}), using fallback method")
            return self._fallback_to_local_execution(workspace_path, asset_manifest, layout_solution)
        except Exception as e:
            self.logger.error(f"Unexpected error in blender-mcp execution: {e}")
            self.logger.info("Attempting fallback to local execution...")
            try:
                return self._fallback_to_local_execution(workspace_path, asset_manifest, layout_solution)
            except Exception as fallback_error:
                self.logger.error(f"Fallback execution also failed: {fallback_error}")
                raise Exception(f"Both blender-mcp and fallback execution failed: {e}, {fallback_error}")

    def _fallback_to_script_generation(self, session) -> str:
        """Fallback: Generate Blender script for manual execution."""
        script_path = session.session_dir / "apply_layout_manual.py"

        # Read the standard apply script template
        apply_script_template = '''
# Blender Manual Layout Apply Script
# Generated by Holodeck-Gemini

import os, json
import bpy

# Set this from your workspace
workspace_path = r"REPLACE_WITH_WORKSPACE_PATH"

def load_json(rel):
    path = os.path.join(workspace_path, rel)
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

asset_manifest = load_json("asset_manifest.json")
layout = load_json("layout_solution_v1.json")

# Import and apply layout logic here...
print("Manual script generated. Run this in Blender.")
'''

        # Replace placeholder with actual workspace path
        script_content = apply_script_template.replace(
            'r"REPLACE_WITH_WORKSPACE_PATH"',
            f'r"{session.session_dir}"'
        )

        with open(script_path, 'w', encoding='utf-8') as f:
            f.write(script_content)

        self.logger.info(f"Generated manual script: {script_path}")
        return str(script_path)

    def _fallback_to_local_execution(self, workspace_path: str,
                                    asset_manifest: Dict[str, Any],
                                    layout_solution: Dict[str, Any]) -> str:
        """Fallback: Execute locally using Blender executable."""
        # This would use the original assemble_scene method
        # For now, generate the script and return the expected blend path
        blend_path = f"{workspace_path}/blender_scene.blend"
        self.logger.info(f"Fallback: Expected blend file at {blend_path}")
        return blend_path

    def render_scene(self, session, cameras: str = "default") -> list:
        """Render scene from multiple camera angles via blender-mcp.

        Args:
            session: SyncSession object with workspace data
            cameras: Camera configuration ("default", "all", or specific camera list)

        Returns:
            List of rendered image paths
        """
        try:
            self.logger.info(f"Rendering scene for session {session.session_id} via blender-mcp")

            # Import here to avoid circular imports
            try:
                from holodeck_core.blender.mcp_bridge import BlenderMCPBridge
                bridge = BlenderMCPBridge()

                # Generate render script
                render_script = self._generate_render_script(session, cameras)

                # Execute via blender-mcp
                workspace_path = str(session.session_dir)
                result = bridge.apply_layout(workspace_path)  # Reuse apply_layout for now

                if result.get("success", False):
                    # Return expected render paths
                    render_paths = [
                        str(session.session_dir / "renders" / "render_default.png"),
                        str(session.session_dir / "renders" / "render_angle1.png"),
                        str(session.session_dir / "renders" / "render_angle2.png")
                    ]
                    self.logger.info(f"Scene rendering completed: {len(render_paths)} images")
                    return render_paths
                else:
                    raise Exception(f"blender-mcp rendering failed: {result.get('error', 'Unknown error')}")

            except ImportError:
                self.logger.warning("BlenderMCPBridge not available for rendering, using fallback")
                return self._fallback_render_generation(session)

        except Exception as e:
            self.logger.error(f"Scene rendering failed: {e}")
            # Return empty list for now - rendering is optional
            return []

    def _fallback_render_generation(self, session) -> list:
        """Fallback: Generate render script for manual execution."""
        script_path = session.session_dir / "render_scene_manual.py"

        render_script = f'''# Blender Manual Render Script
# Generated by Holodeck-Gemini

import bpy
import os

workspace_path = r"{session.session_dir}"

# Basic render setup
bpy.context.scene.render.engine = 'CYCLES'
bpy.context.scene.render.resolution_x = 1920
bpy.context.scene.render.resolution_y = 1080
bpy.context.scene.render.image_settings.file_format = 'PNG'

# Create renders directory
renders_dir = os.path.join(workspace_path, "renders")
os.makedirs(renders_dir, exist_ok=True)

# Render
bpy.context.scene.render.filepath = os.path.join(renders_dir, "render_default.png")
bpy.ops.render.render(write_still=True)

print("Manual render script generated. Run this in Blender.")
'''

        with open(script_path, 'w', encoding='utf-8') as f:
            f.write(render_script)

        self.logger.info(f"Generated manual render script: {script_path}")
        return [str(session.session_dir / "renders" / "render_default.png")]

    def _generate_render_script(self, session, cameras: str) -> str:
        """Generate Blender script for scene rendering."""
        script_lines = [
            "# Blender scene render script",
            "# Generated by Holodeck-Gemini",
            "",
            "import bpy",
            "import math",
            "import os",
            "from pathlib import Path",
            "",
            f"workspace_path = r'{session.session_dir}'",
            "",
            "def setup_render_settings():",
            "    \"\"\"Setup render settings for high quality output.\"\"\"",
            "    scene = bpy.context.scene",
            "",
            "    # Use Cycles renderer",
            "    scene.render.engine = 'CYCLES'",
            "    ",
            "    # Set resolution",
            "    scene.render.resolution_x = 1920",
            "    scene.render.resolution_y = 1080",
            "    scene.render.resolution_percentage = 100",
            "",
            "    # Set output format",
            "    scene.render.image_settings.file_format = 'PNG'",
            "    scene.render.image_settings.color_mode = 'RGBA'",
            "",
            "    # Create renders directory",
            "    renders_dir = os.path.join(workspace_path, 'renders')",
            "    os.makedirs(renders_dir, exist_ok=True)",
            "    ",
            "    return renders_dir",
            "",
            "def create_render_camera(location, rotation, name):",
            "    \"\"\"Create a camera for rendering.\"\"\"",
            "    bpy.ops.object.camera_add(location=location, rotation=rotation)",
            "    camera = bpy.context.active_object",
            "    camera.name = name",
            "    return camera",
            "",
            "def render_from_angle(camera_name, output_path):",
            "    \"\"\"Render scene from specific camera angle.\"\"\"",
            "    camera = bpy.data.objects.get(camera_name)",
            "    if camera:",
            "        bpy.context.scene.camera = camera",
            "        bpy.context.scene.render.filepath = output_path",
            "        bpy.ops.render.render(write_still=True)",
            "        print(f'Rendered: {{output_path}}')",
            "    else:",
            "        print(f'Camera {{camera_name}} not found')",
            "",
            "def main():",
            "    print('Starting Holodeck scene rendering...')",
            "",
            "    renders_dir = setup_render_settings()",
            "    "
        ]

        # Add camera setup based on cameras parameter
        if cameras == "default":
            script_lines.extend([
                "    # Create default camera",
                "    default_cam = create_render_camera((3, -3, 2), (math.radians(60), 0, math.radians(45)), 'RenderCam_Default')",
                "",
                "    # Render from default angle",
                "    render_from_angle('RenderCam_Default', os.path.join(renders_dir, 'render_default.png'))",
                ""
            ])
        elif cameras == "all":
            script_lines.extend([
                "    # Create multiple cameras",
                "    cam1 = create_render_camera((3, -3, 2), (math.radians(60), 0, math.radians(45)), 'RenderCam_Default')",
                "    cam2 = create_render_camera((-3, 3, 2), (math.radians(60), 0, math.radians(-135)), 'RenderCam_Angle1')",
                "    cam3 = create_render_camera((0, -5, 3), (math.radians(75), 0, math.radians(90)), 'RenderCam_Angle2')",
                "",
                "    # Render from all angles",
                "    render_from_angle('RenderCam_Default', os.path.join(renders_dir, 'render_default.png'))",
                "    render_from_angle('RenderCam_Angle1', os.path.join(renders_dir, 'render_angle1.png'))",
                "    render_from_angle('RenderCam_Angle2', os.path.join(renders_dir, 'render_angle2.png'))",
                ""
            ])

        script_lines.extend([
            "    print('Scene rendering completed successfully!')",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ])

        return "\n".join(script_lines)
    def _apply_consistent_scale(self, obj, scale_x: float, scale_y: float, scale_z: float):
        """应用一致的缩放，避免变形"""
        import bpy

        # 检查缩放是否一致
        if abs(scale_x - scale_y) > 0.1 or abs(scale_y - scale_z) > 0.1 or abs(scale_x - scale_z) > 0.1:
            self.logger.warning(f"检测到非一致缩放: X={scale_x}, Y={scale_y}, Z={scale_z}")
            self.logger.warning("这可能导致模型变形，建议使用统一缩放")

            # 计算平均缩放
            avg_scale = (scale_x + scale_y + scale_z) / 3.0
            self.logger.info(f"使用平均缩放值: {avg_scale} 以避免变形")

            # 应用统一缩放
            obj.scale = (avg_scale, avg_scale, avg_scale)
        else:
            # 缩放基本一致，直接应用
            obj.scale = (scale_x, scale_y, scale_z)

        # 应用缩放变换
        bpy.context.view_layer.update()
        bpy.ops.object.transform_apply(location=False, rotation=False, scale=True)
